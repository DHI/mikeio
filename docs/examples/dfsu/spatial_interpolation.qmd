---
title: Dfsu - 2D interpolation
jupyter: python3
description: Interpolate dfsu data to a grid, save as dfs2 and geotiff. Interpolate dfsu data to another mesh.
---


```{python}
import mikeio
```

```{python}
ds = mikeio.read("../../data/wind_north_sea.dfsu", items="Wind speed")
ds
```

```{python}
da = ds.Wind_speed
da.plot();
```

## Interpolate to grid
1. Get an overset grid covering the domain
2. Then interpolate all data to the new grid and plot. 
4. The interpolated data is then saved to a dfs2 file.

```{python}
g = da.geometry.get_overset_grid(dx=0.1)
g
```

```{python}
da_grid = da.interp_like(g)
da_grid
```

```{python}
da_grid.plot();
```

## Save to dfs2 file

```python
da_grid.to_dfs("wind_north_sea_interpolated.dfs2")
```

![](../../images/dfsu_grid_interp.png)

## Save to NetCDF

```python
xr_da = da_grid.to_xarray()
xr_da.to_netcdf("wind_north_sea_interpolated.nc")
```

![](../../images/dfsu_grid_netcdf.png)

## Save to GeoTiff

::: callout-note

This section requires the [`rasterio`](https://rasterio.readthedocs.io/en/latest/installation.html) package.

:::

```python
import numpy as np
import rasterio
from rasterio.transform import from_origin

with rasterio.open(
     fp='wind.tif',
     mode='w',
     driver='GTiff',
     height=g.ny,
     width=g.nx,
     count=1,
     dtype=da.dtype,
     crs='+proj=latlong', # adjust accordingly for projected coordinate systems
     transform=from_origin(g.bbox.left, g.bbox.top, g.dx, g.dy)
     ) as dst:
        dst.write(np.flipud(da_grid[0].to_numpy()), 1) # first time_step
    
```

![](../../images/dfsu_grid_interp_tiff.png)

# Interpolate to other mesh
Interpolate the data from this coarse mesh onto a finer resolution mesh

```{python}
msh = mikeio.Mesh("../../data/north_sea_2.mesh")
msh
```

```{python}
dsi = da.interp_like(msh.geometry)
dsi
```

```{python}
da[0].plot(figsize=(9,7), show_mesh=True);
```

```{python}
dsi[0].plot(figsize=(9,7), show_mesh=True);
```

### Note: 3 of the new elements are outside the original mesh and data are therefore NaN by default

```{python}
import numpy as np

nan_elements = np.where(np.isnan(dsi[0].to_numpy()))[0]
nan_elements
```

```{python}
da.geometry.contains(msh.element_coordinates[nan_elements,:2])
```

### We can force extrapolation to avoid the NaN values

```{python}
dat_interp = da.interp_like(msh.geometry, extrapolate=True)
```

```{python}
n_nan_elements = np.sum(np.isnan(dat_interp.values))
n_nan_elements
```

## Interpolate scatter data to mesh

We want to interpolate scatter data onto an existing mesh and create a new dfsu with the interpolated data.

Since MIKE IO doesn't provide scatter-to-mesh interpolation in its public API, we'll implement a simple Inverse Distance Weighting (IDW) function that you can copy and adapt for your needs.

```{python}
def simple_idw(source_xy, source_values, target_xy, p=2, is_geo=False):
    """Inverse Distance Weighting interpolation.

    Parameters
    ----------
    source_xy : array-like, shape (n_source, 2)
        Coordinates of source points (x, y)
    source_values : array-like, shape (n_source,)
        Values at source points
    target_xy : array-like, shape (n_target, 2)
        Coordinates of target points (x, y)
    p : float, optional
        Power parameter (default=2)
    is_geo : bool, optional
        Use geographic distance calculation (default=False)

    Returns
    -------
    np.ndarray, shape (n_target,)
        Interpolated values at target points
    """
    from scipy.spatial.distance import cdist

    # Calculate distances between all target and source points
    if is_geo:
        # For geographic coordinates, use haversine-like distance
        # (simplified, for production use proper geodesic distance)
        from mikeio.spatial._distance import dist_in_meters
        distances = np.array([
            dist_in_meters(source_xy, target_xy[i], is_geo=True)
            for i in range(len(target_xy))
        ])
    else:
        # Euclidean distance
        distances = cdist(target_xy, source_xy)

    # Calculate IDW weights
    MIN_DISTANCE = 1e-8
    weights = np.where(distances < MIN_DISTANCE, 1.0, 1.0 / distances**p)

    # Normalize weights (rows sum to 1)
    weights = weights / weights.sum(axis=1, keepdims=True)

    # Interpolate
    return weights @ source_values
```

```{python}
dfs = mikeio.open("../../data/wind_north_sea.dfsu")
```

```{python}
dfs.geometry.plot.mesh();
```

```{python}
# scatter data: x,y,value for 4 points
scatter = np.array([[1,50,1], [4, 52, 3], [8, 55, 2], [-1, 55, 1.5]])
scatter
```

Now interpolate from scatter points to all mesh elements using our IDW function:

```{python}
dati = simple_idw(
    source_xy=scatter[:, :2],
    source_values=scatter[:, 2],
    target_xy=dfs.geometry.element_coordinates[:, :2],
    p=2,
    is_geo=dfs.geometry.is_geo
).reshape(1, -1)  # reshape to (1, n_elements) for single timestep
```

```{python}
da = mikeio.DataArray(data=dati, geometry=dfs.geometry, time=dfs.start_time)
da
```

```{python}
ax = da.plot(title="Interpolated scatter data");
ax.scatter(scatter[:,0], scatter[:,1], s=30, c='red')
```

```python
da.to_dfs("interpolated_scatter.dfsu")
```


